# Nand to Tetris: Building a Modern Computer from First Principles
This repository showcases my journey through the 'Nand to Tetris: Building a Modern Computer from First Principles' course, where I meticulously crafted solutions and implementations. Beginning with fundamental logic gates, I systematically developed a comprehensive computer system, culminating in high-level programming capabilities. This project represents my deep dive into understanding the intricate layers of computer architecture and software development, from the bare essentials to advanced functionalities.

## Project Descriptions
### Project 1: Boolean Logic
In this project, I constructed basic logic gates like AND, OR, and MUX using only NAND gates. These gates are the fundamental building blocks for more complex circuits and systems in a 16-bit machine architecture.

### Project 2: Boolean Arithmetic
This project involved building various arithmetic chips, culminating in the creation of the ALU (Arithmetic-Logic Unit) for the Hack computer. The ALU is essential for performing calculations within the CPU, showcasing how different architectures may design their ALUs uniquely.

### Project 3: Sequential Logic
I developed sequential logic circuits to build the main memory (RAM) of the computer. This project focused on using gate logic to store data persistently and to address memory locations accurately, essential for the computer's functionality.

### Project 4: Machine Language Programming
Here, I wrote low-level assembly programs for the Hack computer, providing hands-on experience with machine language and the assembly process. This project emphasized the translation from symbolic language to binary code and demonstrated how programs execute at the hardware level.

### Project 5: Computer Architecture
Combining previous components, I completed the construction of the Hack computer, including the CPU and memory. This project resulted in a fully functional general-purpose computer capable of running programs written in the Hack machine language.

### Project 6: Assembler
I created an assembler to translate Hack assembly language programs into binary code. This project highlighted the importance of translation tools in software development and marked the beginning of building a higher-level software hierarchy.

### Project 7: VM I: Stack Arithmetic
In this project, I implemented the first part of a virtual machine translator, focusing on stack-based arithmetic and memory access commands. This set the foundation for translating VM language into Hack assembly language.

### Project 8: VM II: Program Control
I extended the VM translator to handle branching and function calling commands, completing the VM language's translation capabilities. This project transformed the basic translator into a full-scale VM translator.

### Project 9: High-Level Language
This project introduced Jack, a simple, Java-like programming language. I developed a small application in Jack, preparing for the construction of a Jack compiler by familiarizing myself with the language's syntax and semantics.

### Project 10: Compiler I: Syntax Analysis
I built the syntax analyzer, the first part of the Jack compiler, which parses Jack programs according to the language's grammar. The analyzer produces an XML representation of the program's structure, setting the stage for code generation.

### Project 11: Compiler II: Code Generation
In this final project, I completed the Jack compiler by adding code generation capabilities. The compiler translates Jack programs into VM code, ready to be executed by the virtual machine, completing the journey from high-level language to executable code.
